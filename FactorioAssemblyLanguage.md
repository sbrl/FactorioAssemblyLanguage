# Factorio Assembly Language

This is a (currently theoretical) assembly language designed with implementing it in Factorio in mind.

 - **Version:** 1.0
 - **Last revised on:** 7th October 2022

Currently, it operates exclusively on integers.


## Conventions
From here on, Factorio Assembly Language will be denoted by the acronym *FAL*.

 - `<NAME>` indicates the name of a compile-time constant. **Must begin with an letter** (i.e. as a regular expression: `[a-zA-Z][a-zA-Z0-9]*`).
 - `<INT>` indicates a placeholder for a any integer value. This could be:
   - A register name (e.g. `R1`/`R2`/etc)
   - The name of a compile-time constant
   - A literal integer value
 - `<LIT>` indicates a literal integer value only.
 - `<REG>` indicates the name of a register: e.g. `R1`/`R2`/`R3`/`R4` etc
 - `<ADDR>` indicates a memory address index: e.g. `#0`/`#22` for a static memory address, or a register name to the value of that register as the memory address.


Term				| Meaning
--------------------|--------------------
compile-time error	| An error generated by the compiler. When raised a compiler MUST NOT generate a blueprint output.
runtime error		| An error raised while the circuit network in a blueprint generated by a compiler is running. Execution of the circuit network MUST stop IMMEDIATELY, and a light MUST turn the colour specified. Optionally, a compiler MAY have an option or flag that is disabled by default to disable generation of runtime error lights.

## Levels
FAL has different levels of functionality. Lower levels are designed to be implemented first, and higher levels later.

In this way, a minimal implementation can be written quickly, and incrementally revised later.

**Levels are indicated by a number in square brackets at the beginning of headers.** Any heading that does not specify a level is considered level 1.

Level	| Description
--------|------------------
1		| Minimum basic system.
2		| External devices
3		| Internal addressed memory
4		| IF/ELSE control flow


## Comments
A double forward slash `//` indicates that the rest of the line is a comment.

A `/*` indicates the start of a multiline comment, which may only be ended by `*/`. Should `*/` be missing, a syntax error is raised.

## Registers
FAL operates **exclusively** on values in registers. The following registers exist:

Register name	| Mapped Symbol	| Level	| Purpose
----------------|---------------|-------|----------------
R1				| `1`			| 1 | General purpose
R2				| `2`			| 1 | General purpose
R3				| `3`			| 1 | General purpose
R4				| `4`			| 1 | General purpose
EA				| `A`			| 2 | External device
EB				| `B`			| 2 | External device
EC				| `C`			| 2 | External device
ED				| `D`			| 2 | External device
EE				| `E`			| 2 | External device
EF				| `F`			| 2 | External device
EG				| `G`			| 2 | External device
EH				| `H`			| 2 | External device

If a register is detected to be unused by a compiler, it MAY decide to omit it from the generated blueprint to save space.

All registers MUST default to a value of `0`.

General purpose registers MUST NOT be altered by any external circuit network.

## [2] External devices
External devices (for example, a display module, an input of a number by e.g. a constant combinator, or some other circuit network circuit) may be communicated with via dedicated external device registers:

 - `EA`
 - `EB`
 - `EC`
 - `ED`
 - `EE`
 - `EF`
 - `EG`
 - `EH`

External device registers MUST be usable as both an output AND an input.

External devices themselves are out of scope of this specification. The functionality of such devices SHOULD be defined by their own specification documents.

Compilers SHOULD place external device register interfaces in an obvious location in the generated blueprint to clearly indicate to the user the location of the external device register interfaces.

Any compilers implementing optimisations MUST NOT alter reads and/or writes to external registers.


## [3] Internal Memory
An internal memory system for storing additional data beyond the data stored in registers.

Such an internal memory system can be considered an array of integer values of length N, where N is an arbitrary length determined by the program.

The `MEMGET` and `MEMSET` instructions can be used to interact with the internal memory system.

If a compiler detects that the internal memory system is not used by a given input program, then it SHOULD NOT write an internal memory module to the output blueprint to save space.

### Memory address indexes
Memory address indexes, or just simply memory addresses, **start at 0**. They can be specified in 2 ways:

1. A static memory address, denoted by a hash sign `#` prefixing a non-negative integer (e.g. `#0`, `#12`, etc)
2. A register name, in which case the value of that register is used as the memory address index.

If a memory address is out of bounds, a compile-time error MUST be raised where possible. Where it is not possible, a runtime error MUST be raised by turning on a red light next to the part of the combinator(s) that caused the error.


## Assembly instructions
Summary of instructions:

Instruction				| Level	| Description
------------------------|---|----------------------------
`HWCONST <NAME> <LIT>`	| 1 | Defines a hardware constant. **Not accessible to any other instruction.**
`CONST <NAME> <LIT>`	| 1	| Defines a **compile time** constant.
`STORE <INT> <REG>`		| 1	| Stores the given value in a register.
`ADD <INT> <INT> <REG>`	| 1	| Adds 2 numbers, and stores the result.
`SUB <INT> <INT> <REG>`	| 1	| Subtracts the second integer from the first integer, and stores the result.
`MUL <INT> <INT> <REG>`	| 1 | Multiplies 2 numbers, and stores the result.
`DIV <INT> <INT> <REG>`	| 1 | Divides the first number by the second **using integer division**, and stores the result.
`WAIT <INT> <REG_EXD>`	| 2	| Waits until a given external device register contains a given value before continuing execution.
`MEMGET <ADDR> <REG>`	| 3 | Gets the value stored at the specified memory address and stores it in the given register.
`MEMSET <INT> <ADDR>`	| 3 | Sets the value stored at the specified memory address to a given value.


### `HWCONST <NAME> <LIT>`
Sets a hardware constant. **Hardware constants are not available to any other instructions.**

Instead, they are used to declare the properties of the generated blueprint.

 - `<NAME>` indicates the name of the hardware constant to define a value for
 - `<LIT>` is the integer value literal to set the hardware constant to

The following hardware constant `<NAME>`s are recognised:

Name		| Level | Default value	| Purpose
------------|-------|---------------|-------------------
`MEMSIZE`	| 3		| 20			| Specifies the size of the internal memory.


Any hardware constant that is not specified in the table above MUST raise a compile-time error. If a compiler does not implement the level specified for a given hardware constant, then it MUST also raise a compile-time error.

### `CONST <NAME> <INT>`
Defines a compile-time constant. For example:

```asm
CONST FOO 33
```

...defines the compile-time constant `FOO` and sets it to `33`.

**Note:** Compile-time constants are **not available** at runtime.

### `STORE <INT> <REG>`
Stores a given integer value `<INT>` in a given register `<REG>`.

This can be used to copy 1 register to another:

```asm
STORE R1 R2 // source → target; R1 → R2
```

...or to store a constant value in a specific register:

```asm
CONST FOO 5
STORE FOO R1
```

```asm
STORE 78 R1
```

### `ADD <INT> <INT> <REG>`
Adds 2 numbers together, and stores the result in a given register. For example:

```
ADD 4 5 R1
ADD R1 R2 R1
ADD R1 R2 R3
```

### `SUB <INT> <INT> <REG>`
Subtracts the second `<INT>` from the first `<INT>`, and stores the result in a given register. For example:

```
SUB 100 5 R1
SUB R1 R2 R1
SUB R1 R2 R3
```

### `MUL <INT> <INT> <REG>`
Multiplies 2 numbers together, and stores the result in a given register. For example:

```
ADD 4 5 R1
ADD R1 R2 R1
ADD R1 R2 R3
```

### `DIV <INT> <INT> <REG>`
Divides the first `<INT>` by the second `<INT>` **using integer arithmetic**, and stores the result in a given register. For example:

```
DIV 100 10 R1
DIV R1 R2 R1
DIV R1 R2 R3
```

### [2] `WAIT <INT> <REG>`
Waits until a given register `<REG>` contains a given value `<INT>` before continuing execution.

This could be useful to e.g. wait for user input, or the input of some other device.

For example:

```asm
WAIT 4 EA
```
..or:

```asm
WAIT R1 ED
```


### [3] `MEMGET <ADDR> <REG>`
Gets the value stored at the specified memory address and stores it in the given register.

For example:

```asm
MEMGET #0 R1
```

### [3] `MEMSET <INT> <ADDR>`
Sets the value stored at the specified memory address `<ADDR>` to a given value `<INT>`.

For example:

```asm
MEMSET 45 #11
```

...or:

```asm
MEMSET R1 #0
```

## Implementation considerations
A number of considerations have been made to make it easier to implement in Factorio:

 - **A limited number for registers:** This way, a limited number of symbols can be used to represent the register values, and all the register values can be held serially on a single line.
   - For example, a register line / grid might permeate the entire generated output, allowing easy access to the registers anywhere in the program.
 - **Explicit internal memory size specification:** 

## FAQ

### Why an assembly language and not C/C++/My Favourite Language?
Assembly is much easier to implement. Of course, you could implement a high level language on top of this assembly language, or even implement a compiler that compiles an existing higher level language to this assembly language.